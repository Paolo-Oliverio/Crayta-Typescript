import { SourceNode } from "source-map"
import { isConstructorDeclaration } from "typescript"
import ts from "typescript"
import * as tstl from "typescript-to-lua"
import * as lua from "typescript-to-lua/dist/LuaAST"
import * as printer from "typescript-to-lua/dist/LuaPrinter"

//Crayta Printer adds lua.comment to typescript-to-lua to allow comments in lua code.
//Crayta Printer changes syntax of function declaration in tables to get them show in Crayta event properties gui.

type SourceChunk = string | SourceNode;

class CustomPrinter extends tstl.LuaPrinter {
  /* Override printFile */
  protected printFile(file: tstl.File): SourceNode {
    const originalResult = super.printFile(file)
    // Add header comment at the top of the file
    return this.createSourceNode(file, [
      `--[[\n\tLua File Generated by Gamely's Crayta-Typescript\n\thttps://github.com/Paolo-Oliverio/Crayta-Typescript\n--]]\n\n`,
      originalResult,
    ])
  }
  /*
  printComment(comment: string | string[]): SourceChunk {
    log("COMMENTO " + comment)
    return super.printComment(comment)
  }
*/

  public printCallExpression(expression: lua.CallExpression): SourceNode {
    if(this.printExpression(expression.expression).toString() == "lua.comment"){      
      const chunks: SourceChunk[] = []
      if (expression.params.length > 1){
        chunks.push("--[[\n")
        expression.params.forEach(param => {
        let comment = this.printExpression(param).toString()
        chunks.push("\t" + comment.slice(1,-1)+"\n")
        });
        chunks.push("--]]")
      }else {
        chunks.push("--")
        chunks.push(this.printExpression(expression.params[0]).toString().slice(1,-1))
      }
      return this.createSourceNode(expression, chunks)
    }
    return super.printCallExpression(expression)
  }

  private myprintFunctionParameters(expression: lua.FunctionExpression): SourceChunk[] {
    if (expression.params.length > 0 && expression.params[0].text == "self") {
      expression.params.splice(0, 1)
    }
    const parameterChunks = (expression.params ?? []).map((i) => this.printIdentifier(i))

    if (expression.dots) {
      parameterChunks.push(this.printDotsLiteral(expression.dots))
    }

    return this.joinChunksWithComma(parameterChunks)
  }

  public printVariableAssignmentStatement(statement: lua.AssignmentStatement): SourceNode {
    if (lua.isFunctionDefinition(statement)) {
      const reg = /\.(\w+)$/
      if (statement.left[0]["table"]) {
        const expression = statement.right[0]
        const chunks: SourceChunk[] = []
        chunks.push(this.indent())
        chunks.push("function ")
        chunks.push(this.printExpression(statement.left[0]).toString().replace(reg, ":$1"))
        chunks.push("(")
        chunks.push(...this.myprintFunctionParameters(expression))
        chunks.push(")\n")
        this.pushIndent()
        chunks.push(this.printBlock(expression.body))
        this.popIndent()
        chunks.push(this.indent(this.createSourceNode(statement, "end")))
        return this.createSourceNode(statement, chunks)
      }
    }
    return super.printVariableAssignmentStatement(statement)
  }

  /* Override printBoolean */
  /*public printBooleanLiteral(expression: tstl.BooleanLiteral): SourceNode {
    // Print any boolean as 'true'
    return this.createSourceNode(expression, "true")
  }*/
}

const plugin: tstl.Plugin = {
  printer: (program, emitHost, fileName, file) => new CustomPrinter(emitHost, program, fileName).print(file),
}

// eslint-disable-next-line import/no-default-export
export default plugin
